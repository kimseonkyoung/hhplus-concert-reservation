<!--
  제목은 [(과제 STEP)] (작업한 내용) 로 작성해 주세요
  예시: [STEP-9] 이커머스 시스템 설계 
-->
[STEP-15] 인덱스를 통한 쿼리 성능 개선에 대한 고찰
[STEP-16] 콘서트 예약 시스템에서의 트랜잭션 효율화 및 MSA 전환 방향
## 리뷰 포인트
<!-- 
    리뷰어가 함께 고민해주었으면 하는 내용을 간략하게 기재해주세요.
    커밋 링크가 포함되면, 더욱이 효과적일 거예요! 
-->
1. [STEP-15]의 경우 인덱스에 대해 학습하고 실제로 테스트를 통해 성능 향상을 수치적으로 확인할 있었습니다. 
좌석 데이터의 경우 천만건 정도의 데이터를 넣었기 때문에 조회시 극명한 성능 향상을 체감했으나, 콘서트 일정의 경우 백만건의 데이터를 넣었음에도 인덱싱을 하기 전이나 후에서
유의미한 수치가 나오지 않아 테스트 목록에서 제외한 것이 아쉬웠습니다. 해당 데이터는 멘토님이 설명해주신 내용을 바탕으로
CSV Data Infile 방식으로 더미테이터를 생성했습니다. 천만건에 30초 밖에 걸리지 않아 놀라웠습니다. 해당 pr에는 CSV 생성 자바 클래스나
CSV 파일은 포함하지 않았습니다. 해당 보고서는 git wiki에 올려두었습니다. 해당 주소입니다. <br>
[인덱스를 통한 쿼리 성능 개선에 대한 고찰](https://github.com/kimseonkyoung/hhplus-concert-reservation/wiki/10.-인덱스를-통한-쿼리-성능-개선에-대한-고찰)
- 현재는 존재하지 않지만, 후에 요구사항으로 추가될 것을 고려해서 예상 시나리오를 작성했습니다. 실제 서비스를 운영할 때는 예상 가능한 대부분의 시나리오를
판단하여 미리 인덱스를 생성해놓기도 하는지 궁금합니다. 

2. [STEP-16]의 경우 외부 플랫폼 관련 api가 추가되었을 시를 가정하고, springEventPublisher와 Listenner를 통해 이벤트를 발행 구독하여 트랜잭션을 분리하는 기본 과제에
MSA를 가정하고 해당 도메인 서비스를 해체하는 과정에 대해 학습했습니다. 관련해서 MSA의 사가패턴의 주요한 두 가지 방식인
코레오그래피 방식과 오케스트레이션 방식에 대해서 학습하고, 보고서를 작성했습니다. 해당 보고서도 마찬가지로 git wiki에 올려두었습니다. 해당 주소입니다 <br>
[콘서트 예약 시스템에서의 트랜잭션 효율화 및 MSA 전환 방향](https://github.com/kimseonkyoung/hhplus-concert-reservation/wiki/11.--콘서트-예약-시스템에서의-트랜잭션-효율화-및-MSA-전환-방향)

- 현재에는 기본 과제만을 수행하고, 카프카를 적용한 방식에 대해서는 모식도를 통해 구상만 해둔 상태입니다. 
- 현재에는 외부 데이터 플랫폼 전송 api를 따로 분리해 Listener에서 해당 apiClient를 주입받아 사용하고, try ~ catch로 예외처리를 간단하게 하는 식으로 구성했습니다.
- 외부 데이터 플랫폼 전송 api가 실패시 해당 상태를 DB에 저장한 후, 스케줄러를 통해 주기적으로 재시도 처리를 하는 식의 outbox 패턴을 적용해보았습니다. 해당 outbox패턴에서 스케줄러가 재시도 로직을 호출할 때 바로 외부 api를 호출하면 되는 건지, 아니면 주기를 상대적으로 길게 잡아 외부 api를 다시 호출할 있도록
이벤트를 발행해야하는 식으로 해야하는 건지 고민이 됩니다. 이럴 땐 어떻게 하면 좋을지 궁금합니다.
- 해당 외부 api 서버가 장애가 상황에서, 주기적으로 재시도 처리를 하는 것보다 재시도 처리에 횟수의 제한을 두는 방식은 어떤지 궁금합니다.
- 혹은 스케줄러를 이용하지 않고, 따로 재시도 3번 호출 후 실패시 spring 이벤트를 발행해서, 해당 이벤트의 리스너가 다시 해당 재시도 로직을 재귀호출 하도록 하여 외부 api 서버에게 복구할 시간을 주는 방식은 어떨지 궁금합니다.
- 만약 MSA를 가정해서 현재 단일 서버 시스템에서 결제 관련 도메인 서비스를 모두 해체시킨다면, 각각의 서비스에서 로직을 수행하고 이벤트를 발행하고, 그 이벤트를 구독하는 리스너에서 해당 관련된 다음 시행해야될 서비스 로직을 호출하는 식으로 구현되게 되는지 궁금합니다.
- 예를 들어, A -> B -> C 의 로직이 차례대로 각각의 트랜잭션으로 실행된다고 가정했을 때, C가 실패해서 실패 이벤트를 발행하면, A, B 롤백에 관련된 리스너가 이를 수신해서 보상 트랜잭션을 수행하는 A, B의 서비스를 호출하게 되는 건지 궁금합니다.
- 결국 도메인마다 Listener와 publisher를 갖는 패턴이 만들어질 것 같은데, 이때 위의 궁금증과 이어져서 성공, 실패에 상관 없이 해당 도메인 중심으로 발행, 구독이 발생하는 건지,
실패, 성공을 기준으로 발행, 구독 이벤트가 구분되는 건지 궁금합니다.
- 아마 MSA로 전환된다면, 이런 Listener와 publisher의 이벤트(메시지)를 메세지브로커(카프카, 레빗mq, redis pub/sub)으로 관리할 것으로 생각되는데, 이때 이러한 메세지 브로커가 장애가 났을 시를 대비하는 방법에 대해서는 학습을 진행해야될 것 같습니다.
- 이전에 일단 이벤트에 대한 개념을 조금 더 정립하고 메시지 브로커에 대한 학습도 진행하겠습니다.

감사합니다.

 

## Definition of Done (DoD)
<!--
    DOD 란 해당 작업을 완료했다고 간주하기 위해 충족해야 하는 기준을 의미합니다.
    어떤 기능을 위해 어떤 요구사항을 만족하였으며, 어떤 테스트를 수행했는지 등을 명확하게 체크리스트로 기재해 주세요.
    리뷰어 입장에서, 모든 맥락을 파악하기 이전에 작업의 성숙도/완성도를 파악하는 데에 도움이 됩니다.
    만약 계획되거나 연관 작업이나 파생 작업이 존재하는데, 이후로 미뤄지는 경우 TODO -, 사유와 함께 적어주세요.

    ex:
    - [x] 상품 도메인 모델 구조 설계 완료 ( [정책 참고자료](관련 문서 링크) )
    - [x] 상품 재고 차감 로직 유닛/통합 테스트 완료
    - [ ] TODO - 상품 주문 로직 개발 ( 정책 미수립으로 인해 후속 작업에서 진행 )
-->
