
### 동시성 제어 방법에 관한 분석



#### 1. 서론
1.1 프로젝트 배경

현대 웹 서버 프로그래밍에서 가장 중요한 요소 중 하나는 다수의 API 요청을 얼마나 효율적으로 처리할 수 있는지입니다. 대용량 트래픽을 안정적으로 처리하면서, 다수의 요청이 데이터베이스와 같은 공유 자원에 대해 읽기(READ) 및 쓰기(WRITE) 작업을 수행할 때 데이터의 정합성을 유지하는 것은 필수적입니다.

현재 개발 중인 콘서트 예약 시스템에서도 동일 사용자 또는 여러 사용자가 특정 API를 빠르게 연속적으로 호출하는 상황이 발생할 수 있습니다. 특히, 아래와 같은 기능에서 동시성 문제와 데이터 일관성 문제가 두드러질 가능성이 있습니다:

유저 포인트 충전 및 조회: 연속적인 충전 요청(예: '따닥'과 같은 빠른 연속 요청)으로 인해 잔액 정보가 부정확하게 업데이트될 위험이 존재합니다.

​

좌석 예약: 대기열에 있던 다수의 사용자가 예약 페이지로 진입하여 동시에 좌석 예약을 시도하면 데이터 일관성이 깨질 가능성이 높습니다.

​

이러한 정합성 문제는 시스템의 안정성과 신뢰성을 저하시킬 수 있는 주요 원인으로작용할 수 있습니다. 따라서 효과적인 동시성 관리 및 데이터 일관성 유지 전략을 수립하고 구현하는 것이 중요합니다.

​

1.2 **목적**

​

위에서 언급된 동시성 문제를 인식하고 이를 해결하기 위해 본 보고서에서는 현재 시스템 환경과 제약 조건을 분석하고, 효과적인 동시성 제어 방안을 제안하는 데 목적이 있습니다.

​

---

​

#### **2. 실험 환경**

​

2.1 **시스템 구성**

​

프로그래밍 언어 및 프레임워크: Java, Spring Boot, Spring Data JPA

데이터베이스: MySQL (도커 컴포즈를 사용한 컨테이너 기반 실행)

인프라: Redis

​

2.2 **테스트 데이터**

​

- 데이터베이스 구조:

1. User 테이블:

userId (PK): 유저 아이디

balance: 잔액

amount: 충전 금액​

​

2. Seat 테이블:

seatId (PK): 좌석 아이디

concertScheduleId: 콘서트 스케줄 아이디

seatNo: 좌석 번호

seatPrice: 좌석 가격

status: 좌석 상태

​

- 시뮬레이션된 유저 및 요청 수

1. 포인트 충전: 동일 사용자가 연속으로 두 번 동시 충전 요청.

2. 포인트 결제: 동일 사용자가 연속으로 두 번 동시 결제 요청.

3. 좌석 예약: 하나의 좌석을 점유하기 위한 100명, 500명, 1,000명의 동시 요청 시나리오.

---

본 보고서는 위와 같은 실험 환경을 기반으로 시스템 내 동시성 문제와 데이터 일관성 문제를 분석하고, 이를 해결하기 위한 최적의 방안을 탐구하는 데 중점을 둡니다.

---

​

#### **3. 실험 방법론**

​

3.1 **동시성 처리 전략 개요**

​

먼저, JVM 단계에서 동시성 제어를 처리하는 Synchronized나 ReentrantLock의 경우는 다중 인스턴스에서 오는 호출에 대해서는 제어할 수 없기 때문에 해당 보고서에서는 논의 대상에서 제외하고 낙관적 락, 비관적 락, 분산 락에 대한 개념과 구현 방식에 대해 알아보겠습니다.

​

첫 번째로 낙관적 락(Optimistic Lock)입니다. 말 그대로 충돌이 거의 일어나지 않을 것이라는 낙관적인 전제가 성립될 때 사용할 수 있는 방법입니다. DB가 제공하는 락 기능이 아니라 어플리케이션에서 제공하는 버전(@version)관리 기능을 사용합니다. 예를 들어 A와 B가 거의 동시에 DB를 조회한 후, 먼저 A가 쓰기 작업을 진행한다면, 이후 B가 쓰기 작업을 진행할 때 버전 정보가 다를 경우 B의 쓰기 작업을 실패하게 됩니다. 기본적으로 낙관적 락은 버전 충돌이 발생할 경우 해당 트랜잭션을 롤백하기 때문에 요청이 유실되는 것을 막으려면 재처리 로직을 추가해야됩니다. 만약 데이터의 쓰기 작업으로 인한 충돌이 적고, 비즈니스 로직이 중간에 실패해도 문제가 없거나, 여러 요청 중 하나만 성공시키고 나머지를 탈락시킬 경우 사용하면 좋습니다.

​

두 번째로 비관적 락(Pessimistic Lock)입니다. 이는 낙관적 락과 반대로 충돌이 무조건 발생한다는 비관적인 전제에서 출발합니다. DB 측면에서 락을 거는 방식으로, 데이터를 조회할 때 락을 걸어 다른 트랜잭션이 해당 데이터에 접근했을 때 수정하지 못하도록 하는 방식입니다. 트랜잭션이 시작될 때 조회는 가능하고 쓰기는 불가능한 S Lock이나 조회, 쓰기 둘 다 막는 x Lock을 걸고 시작합니다. 소위 'SELECT ... FOR UPDATE' 구문을 사용해 데이터 락을 거는 것이 비관적 락이며, 주로 자원에 대해 충돌이 빈번해, 비즈니스 관점에서 반드시 성공해야 하는 로직이라 판단될 때 사용합니다. 때문에, 데이터 무결성, 정합성은 보장하나 해당 트랜잭션이 접근해 DB에 락을 걸면 다른 트랙잭션이 해당 데이터 row에 접근하지 못하고 대기해야되기 때문에 시스템 성능이 저하될 수 있습니다. 또한 두 트랜잭션이 서로 다른 리소스에 락을 걸고 상호 대기하는 상태가 되면, 데드락(교착상태)이 발생할 수 있습니다.

​

마지막으로 분산락(Distrivuted Lock)은 서버가 여러 대인 상황에서 동일한 데이터의 접근에 동기화를 보장하기 위해 사용됩니다. 서버 간의 동기화 처리가 필요하다는 것은 여러 서버에서 공통된 락을 적용해야 한다는 뜻이기 때문에 주로 redis를 이용하여 분산락을 이용합니다. 이는 공유락, 배타락을 활용하여 테이블, 레코드에 락을 거는 DB락 방식과 동일하다고 생각될 수 있으나, 분산락은 공유자원 자체에 락을 거는 게 아니라 어떤 행위가 발생하는 임계구역(Critical Section)에 락을 거는 방식이라고 할 수 있습니다. redis를 활용해 분산락을 이용하는 방식에는 Lettuce 방식과 Redisson 방식이 존재합니다만, Lettuce 방식은 Spin Lock 방식으로 Lock을 획득할 때까지 계속 루프를 돌기 때문에 redis에 많은 부하를 줄 수 있습니다. 이로 인해 본 보고서에서는 Redisson 방식의 분산락에 대해서만 다루도록 하겠습니다.

​

​

3.2 **테스트 시나리오**

​

### **3.2.1. 포인트 충전 테스트 시나리오**

​

#### **3.2.1.1 동일 사용자 두 번 연속 충전 요청**

​

- **설정**

- 사용자 ID: `1`

- 초기 잔액: `1000`

- 충전 요청 금액: `500`

- 동시 요청 수: `2`

- **테스트 목표**

- 충전 요청이 순차적으로 처리되어 잔액이 `2000`으로 정확히 업데이트되는지 확인.

- 데이터베이스 트랜잭션 충돌 여부 확인.

- **테스트 결과 확인 방법**

- 잔액 확인: `SELECT point FROM User WHERE userId = '1';`

- 충전 로그 확인: `SELECT * FROM point WHERE userId = '1';`

​

---

​

### **3.2.2. 좌석 예약 테스트 시나리오**

​

#### **3.2.2.1 동일 좌석에 대한 두 번 연속 예약 요청**

​

- **설정**

- 좌석 ID: `1`

- 사용자 ID: `1`

- 좌석 초기 상태: `AVAILABLE`

- 동시 요청 수: `2`

- **테스트 목표**

- 두 요청 중 하나만 성공하고, 나머지 요청은 실패하는지 확인.

- 좌석 상태가 `COMLETED`로 정확히 업데이트되는지 확인.

- **테스트 결과 확인 방법**

- 좌석 상태 확인: `SELECT status FROM Seat WHERE seatId = '1';`

- 좌석 예약 로그 확인: `SELECT * FROM Reservation WHERE seatId = '1';`

​

#### **3.2.3 다중 사용자의 동일 좌석 예약 요청**

​

- **설정**

- 좌석 ID: `1`

- 사용자 ID: `1`, `2`, ..., `100`

- 좌석 초기 상태: `AVAILABLE`

- 동시 요청 수: `100`

- **테스트 목표**

- 100명 중 한 명만 성공하고, 나머지 사용자는 실패하는지 확인.

- 데이터베이스가 동시 요청을 처리하며 충돌 없이 일관성을 유지하는지 확인.

- **테스트 결과 확인 방법**

- 좌석 상태 확인: `SELECT status FROM Seat WHERE seatId = 'seat2';`

- 좌석 예약 성공/실패 로그 확인.

-

#### **3.2.4 다중 좌석에 대한 예약 요청**

​

- **설정**

- 좌석 ID: `3`, `4`, `5`

- 사용자 ID: `1`, `2`, ..., `10`

- 좌석 초기 상태: `AVAILABLE`

- 동시 요청 수: `10`

- **테스트 목표**

- 좌석이 순차적으로 예약되며, 중복 예약이 발생하지 않는지 확인.

- 각 좌석 상태가 `COMLETED`로 정확히 업데이트되는지 확인.

- **테스트 결과 확인 방법**

- 좌석 상태 확인: `SELECT seatId, status FROM Seat WHERE seatId IN ('3', '4', '5');`

- 좌석별 예약 성공/실패 로그 확인.

​

### **3. 동시성 처리 전략별 비교 테스트**

​

#### **4.1 낙관적 락**

​

- **테스트 목표**

- 충전 요청 및 좌석 예약 시 버전 관리가 충돌을 방지하는지 확인.

- 충돌 발생 시 재시도 로직의 효과 검증.

- **테스트 시나리오**

- 동일 좌석을 100명의 사용자가 낙관적 락을 통해 예약 시도.

​

#### **3.2 비관적 락**

​

- **테스트 목표**

- 충전 요청 및 좌석 예약 시 트랜잭션이 올바르게 락을 걸어 데이터 정합성을 유지하는지 확인.

- 락으로 인한 성능 저하 및 데드락 발생 가능성 분석.

- **테스트 시나리오**

- 동일 좌석에 대한 두 번 연속 예약 요청을 비관적 락으로 처리.

​

#### **3.3 분산 락**

​

- **테스트 목표**

- 여러 서버에서 분산 락을 사용해 동일 자원 접근 시 정합성을 유지하는지 확인.

- Redis를 활용한 락의 성능 및 안정성 평가.

​

​

#### **4. 실험 결과 및 분석**

​

4.1 **결과 데이터**

4.1.1 포인트 충전

(1) 락 X : 테스트 결과 실패 

(2) 낙관적락: 테스트 성공


(3) 비관적락: 테스트 성공


- 각 락 유형의 처리 시간 비교 (평균, 최댓값, 최솟값 등)

- 성공/실패 요청 비율![스크린샷 2025-01-23 오전 8.39.58.png](../../../Desktop/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202025-01-23%20%EC%98%A4%EC%A0%84%208.39.58.png)

​

4.2 **분석 및 비교**

​

- 성능 차이 분석

- 특정 락의 우수한 조건 및 한계점

​

---

​

#### **5. 결론 및 제안**

​

5.1 **결론 요약**

​

- 실험 결과 요약 및 동시성 처리 전략의 적합성 평가

​

5.2 **제안 사항**

​

- 프로젝트에서 사용할 권장 동시성 제어 방법

- 실험의 한계 및 추가 연구 필요성

​

---

​

#### **6. 참고 자료**

​

- 사용된 논문, 기술 자료, 공식 문서 링크

​

---

​

#### **부록**

​

- 코드 스니펫, SQL 쿼리 예제

- 실험 데이터 (그래프, 표 등)

```

​