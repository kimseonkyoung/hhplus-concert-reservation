시스템 분석 및 설계 문서

토큰 발급과 대기열

1. UUID 판단 키

대기열에서 UUID를 **상태(status)**와 **유효 시간(expiration)**으로 관리합니다.

키 값: UUID

UUID는 고유 식별자로 사용되며, 각 대기열 항목의 상태를 조회 및 업데이트할 때 활용됩니다.

status 필드는 WAIT, ACTIVE, EXPIRED 등의 상태를 나타냅니다.

2. 만료된 토큰 및 비활성화 토큰 관리

Redis TTL 활용:

Redis에 저장된 토큰에 TTL을 설정하여 만료 시 자동 삭제.

비활성화된 토큰은 EXPIRED 상태로 변경 후 삭제 처리.

주기적 스케줄러:

만료되지 않은 상태의 토큰은 스케줄러(Spring Scheduler)로 주기적으로 검사 및 삭제.

EXPIRED 상태의 토큰과 이미 처리된 토큰(예약 성공/실패)은 백그라운드 작업으로 제거.

3. WAIT 상태의 대기 순서 및 예측 시간 반환

대기 순서:

created_at(등록 시간)을 기준으로 정렬.

ROW_NUMBER() 또는 Redis Sorted Set을 사용하여 순서를 반환.

예측 시간:

각 대기열 항목의 평균 처리 시간을 기준으로 남은 대기 시간을 계산.

예: 남은 대기 시간 = (대기열 순서) x (평균 처리 시간)

4. 대기열 방식: 은행창구식 vs 놀이동산식

은행창구식:

여러 리소스(좌석 처리기)를 병렬로 처리.

창구별로 대기열을 분리하여 처리 속도 증가.

사용 사례: 동시에 여러 좌석이 예약 가능한 경우.

놀이동산식:

단일 대기열에서 순차적으로 처리.

공정성을 보장하며, 단일 리소스 처리에 적합.

사용 사례: 특정 좌석만 예약 가능하거나 공정성이 중요한 경우.

추천 방식:

좌석 예약 시스템에서는 놀이동산식을 기본으로 하되, 여러 좌석 처리기 병렬 처리가 가능하면 은행창구식을 병행.

자리 예약

1. 동시성 처리 (다수 유저 요청)

Optimistic Locking:

좌석 예약 시 버전 번호를 체크하여 동시 업데이트 방지.

분산 락 (Redis):

특정 좌석 ID를 키로 분산 락을 생성.

락을 획득한 유저만 예약 가능.

트랜잭션:

데이터베이스 트랜잭션으로 상태 변경 원자성을 보장.

2. 5분 만료 처리

TTL 기반 만료:

Redis에 좌석 예약 정보를 저장하고 TTL 설정.

TTL 만료 시 좌석 상태를 자동 초기화.

스케줄러:

스케줄러(Spring Scheduler)를 사용해 배정된 좌석을 주기적으로 확인.

만료된 좌석을 AVAILABLE 상태로 변경.

포인트 충전 및 사용

1. 잔액 정합성 유지

트랜잭션 관리:

모든 충전 및 사용 요청을 트랜잭션으로 처리.

충전/사용 중 오류 발생 시 롤백.

Optimistic Locking:

포인트 잔액에 버전 필드를 추가하여 중복 업데이트 방지.

분산 환경:

분산 시스템에서는 Redis 락 또는 Saga 패턴으로 정합성을 보장.

예외 처리

1. 전역 예외 처리

Global Exception Handler:
Spring의 @RestControllerAdvice를 사용하여 예외를 전역 처리.
클라이언트가 이해하기 쉬운 메시지를 반환.

2. 예외 메시지 형식

{
"errorCode": "SEAT_ALREADY_RESERVED",
"message": "The seat is already reserved."
}

3. 주요 실패 케이스

좌석 예약 실패:
이유: 좌석 중복 예약, 토큰 만료.
해결: 중복 좌석 방지 및 대체 좌석 추천.

잔액 부족:
이유: 결제 시 잔액 부족.
해결: 충전 안내 및 즉시 충전 기능 제공.
토큰 만료:

이유: 대기열에서 오래 대기.

해결: 재발급 프로세스 제공.

패키지 구조: DDD 지향

1. 계층 구조

com.example.project
├── domain
│   ├── model        # Entity 및 VO 정의
│   ├── repository   # Repository 인터페이스
│   ├── service      # 비즈니스 로직
├── application
│   ├── dto          # 요청/응답 DTO
│   ├── facade       # 유즈케이스(애플리케이션 서비스)
│   ├── mapper       # DTO ↔ Entity 변환
├── infra
│   ├── persistence  # DB 관련 구현체
│   ├── scheduler    # 스케줄러 구현
│   ├── exception    # 공통 예외 처리
├── config           # 설정 파일

2. 레이어 의존 방향

외부 → 내부로:

infra → application → domain

domain은 다른 레이어에 의존하지 않음.

3. Facade의 역할

존재 의의:

여러 도메인 서비스의 조합 및 응용 로직 처리.

클라이언트 요청을 받아 DTO와 도메인 간 변환을 담당.

문서화

1. 시퀀스 다이어그램

유저 요청 → 대기열 확인 → 좌석 예약 → 결제까지의 흐름.

2. 플로우차트

대기열 관리, 좌석 예약, 결제 실패 시 대체 좌석 추천 등의 주요 흐름 시각화.

3. ERD 설계

주요 테이블:

users (유저 정보)

tokens (대기열 토큰 관리)

seats (좌석 상태)

transactions (포인트 충전/사용 내역)

효율적인 테이블 설계

1. FK 지양

외래 키(FK)를 지양하고, 대신 애플리케이션에서 참조 무결성을 관리.

이유: 대규모 시스템에서 성능 저하를 방지.

마무리

이 설계 문서는 효율적이고 확장 가능한 시스템 구현을 위한 방향성을 제공합니다. 추가 요구사항이 있을 경우 문서에 업데이트가 필요합니다.

